/**
 * Builder Export Service
 *
 * Handles exporting generated code as ZIP files with user preferences.
 * Supports domain-specific branding and multiple output formats.
 */

const fs = require('fs').promises;
const path = require('path');

class BuilderExportService {
  constructor(storagePath = './storage/generated/projects') {
    this.storagePath = storagePath;
  }

  /**
   * Initialize storage directories
   */
  async initialize() {
    try {
      await fs.mkdir(this.storagePath, { recursive: true });
      console.log('[BuilderExportService] Storage initialized:', this.storagePath);
      return true;
    } catch (error) {
      console.error('[BuilderExportService] Init failed:', error);
      throw error;
    }
  }

  /**
   * Export session as a single concatenated file (simpler than ZIP)
   * Returns all files concatenated with separators
   */
  async exportAsTarball(sessionId, session, preferences = {}) {
    let output = `# Project Export: ${sessionId}\n`;
    output += `# Generated: ${new Date().toISOString()}\n`;
    output += `# Files: ${session.generatedFiles.length}\n\n`;
    output += `${'='.repeat(80)}\n\n`;

    // Add each file with separator
    session.generatedFiles.forEach((file, index) => {
      output += `## File ${index + 1}: ${file.filename}\n`;
      output += `## Task: ${file.task}\n`;
      output += `${'='.repeat(80)}\n`;
      output += this.applyBranding(file.code, preferences);
      output += `\n\n${'='.repeat(80)}\n\n`;
    });

    // Add package.json section
    const packageJson = this.generatePackageJson(sessionId, preferences);
    output += `## package.json\n`;
    output += `${'='.repeat(80)}\n`;
    output += JSON.stringify(packageJson, null, 2);
    output += `\n\n${'='.repeat(80)}\n\n`;

    // Add README section
    const readme = this.generateReadme(sessionId, session, preferences);
    output += `## README.md\n`;
    output += `${'='.repeat(80)}\n`;
    output += readme;
    output += `\n\n${'='.repeat(80)}\n`;

    return Buffer.from(output, 'utf8');
  }

  /**
   * Save project to storage directory
   */
  async saveToStorage(sessionId, session, preferences = {}) {
    const projectDir = path.join(this.storagePath, sessionId);
    const srcDir = path.join(projectDir, 'src');

    await fs.mkdir(srcDir, { recursive: true });

    // Write each generated file
    for (const file of session.generatedFiles) {
      const content = this.applyBranding(file.code, preferences);
      const filePath = path.join(srcDir, file.filename);
      await fs.writeFile(filePath, content, 'utf8');
    }

    // Write package.json
    const packageJson = this.generatePackageJson(sessionId, preferences);
    await fs.writeFile(
      path.join(projectDir, 'package.json'),
      JSON.stringify(packageJson, null, 2),
      'utf8'
    );

    // Write README
    const readme = this.generateReadme(sessionId, session, preferences);
    await fs.writeFile(path.join(projectDir, 'README.md'), readme, 'utf8');

    // Write manifest
    const manifest = {
      sessionId,
      createdAt: session.createdAt,
      exportedAt: new Date().toISOString(),
      model: session.model,
      fileCount: session.generatedFiles.length,
      preferences
    };
    await fs.writeFile(
      path.join(projectDir, 'manifest.json'),
      JSON.stringify(manifest, null, 2),
      'utf8'
    );

    return {
      path: projectDir,
      files: session.generatedFiles.length + 3, // +3 for package.json, README, manifest
      url: `/generated/projects/${sessionId}`
    };
  }

  /**
   * Apply user branding to code
   */
  applyBranding(code, preferences) {
    if (!preferences.branding) return code;

    let branded = code;

    // Add header comment with branding
    if (preferences.branding.domain) {
      const header = `/**
 * Generated by CALOS Builder
 * Domain: ${preferences.branding.domain}
 * ${preferences.branding.tagline || ''}
 */

`;
      branded = header + code;
    }

    return branded;
  }

  /**
   * Generate package.json with user preferences
   */
  generatePackageJson(sessionId, preferences) {
    const domain = preferences.branding?.domain || 'calos.com';
    const projectName = preferences.projectName || `project-${sessionId}`;

    return {
      name: projectName,
      version: '1.0.0',
      description: `Generated by CALOS Builder on ${domain}`,
      main: 'src/setup-0.js',
      scripts: {
        start: 'node src/backend-2.js',
        test: 'node src/testing-8.js',
        dev: 'nodemon src/backend-2.js'
      },
      keywords: ['calos', 'ai-generated', domain],
      author: preferences.author || 'CALOS User',
      license: 'MIT',
      dependencies: {
        express: '^4.18.2',
        ...(preferences.dependencies || {})
      },
      devDependencies: {
        nodemon: '^3.0.1'
      },
      engines: {
        node: '>=18.0.0'
      }
    };
  }

  /**
   * Generate README with project documentation
   */
  generateReadme(sessionId, session, preferences) {
    const domain = preferences.branding?.domain || 'calos.com';
    const colors = preferences.branding?.colors || ['#667eea'];

    return `# ${preferences.projectName || 'AI Generated Project'}

**Generated by CALOS Builder**
- Domain: ${domain}
- Model: ${session.model}
- Session: ${sessionId}
- Created: ${session.createdAt}

## Project Structure

\`\`\`
project/
├── src/
${session.generatedFiles.map(f => `│   ├── ${f.filename}`).join('\n')}
├── package.json
└── README.md
\`\`\`

## Generated Files

${session.generatedFiles.map((f, i) => `
### ${i + 1}. ${f.filename}
**Task:** ${f.task}
**Generated:** ${f.timestamp}
`).join('\n')}

## Quick Start

\`\`\`bash
npm install
npm start
\`\`\`

## Branding

${preferences.branding ? `
- **Colors:** ${colors.join(', ')}
- **Domain:** ${domain}
- **Style:** ${preferences.branding.voice || 'Professional'}
` : 'Default CALOS branding'}

## About CALOS

This project was generated using the CALOS AI Builder platform.
Visit [${domain}](https://${domain}) to create your own AI-powered applications.

---

*Generated with ❤️ by CALOS Builder*
`;
  }

  /**
   * Get file extension based on output format preference
   */
  getFileExtension(preferences) {
    const formats = {
      'js': '.js',
      'ts': '.ts',
      'jsx': '.jsx',
      'tsx': '.tsx',
      'vue': '.vue'
    };
    return formats[preferences.fileType] || '.js';
  }
}

module.exports = BuilderExportService;
