/**
 * GitHubAppPublisher
 *
 * Automatically publishes generated apps to GitHub:
 * - Creates repos
 * - Pushes code
 * - Sets up GitHub Pages/Actions
 * - Configures webhooks
 *
 * Works with API-to-App generator output to deploy apps instantly.
 *
 * Usage:
 *   const publisher = new GitHubAppPublisher({ githubToken });
 *   await publisher.publishApp('/path/to/generated/app', {
 *     name: 'my-card-game',
 *     description: 'Awesome card game',
 *     private: false
 *   });
 */

const { Octokit } = require('@octokit/rest');
const simpleGit = require('simple-git');
const fs = require('fs').promises;
const path = require('path');

class GitHubAppPublisher {
  constructor(options = {}) {
    this.githubToken = options.githubToken || process.env.GITHUB_TOKEN;
    this.webhookUrl = options.webhookUrl || process.env.WEBHOOK_URL;
    this.db = options.db;

    if (!this.githubToken) {
      throw new Error('GitHub token required (GITHUB_TOKEN env var)');
    }

    this.octokit = new Octokit({ auth: this.githubToken });

    console.log('[GitHubAppPublisher] Initialized');
  }

  /**
   * Publish an app to GitHub
   * @param {string} appPath - Path to generated app
   * @param {object} options - Publish options
   * @returns {Promise<object>} - Publication result
   */
  async publishApp(appPath, options = {}) {
    const {
      name,
      description = 'Generated by CALOS Agent Router',
      private: isPrivate = false,
      username = null, // User's GitHub username (for forking to their account)
      enablePages = true,
      enableActions = true
    } = options;

    if (!name) throw new Error('App name required');

    console.log(`[GitHubAppPublisher] Publishing ${name}...`);

    try {
      // 1. Create GitHub repo
      const repo = await this.createRepo(name, description, isPrivate, username);

      // 2. Initialize git in app directory
      const git = simpleGit(appPath);
      await git.init();
      await git.addConfig('user.name', 'CALOS Agent Router');
      await git.addConfig('user.email', 'noreply@calos.dev');

      // 3. Add all files
      await git.add('.');
      await git.commit('Initial commit - Generated by CALOS');

      // 4. Add remote and push
      const remoteUrl = `https://${this.githubToken}@github.com/${repo.full_name}.git`;
      await git.addRemote('origin', remoteUrl);
      await git.push('origin', 'main', ['--set-upstream']);

      console.log(`[GitHubAppPublisher] Pushed to ${repo.html_url}`);

      // 5. Enable GitHub Pages
      if (enablePages) {
        await this.enableGitHubPages(repo.owner.login, repo.name);
      }

      // 6. Enable GitHub Actions
      if (enableActions) {
        await this.setupGitHubActions(appPath, repo.owner.login, repo.name);
      }

      // 7. Set up webhook (for deployment notifications)
      if (this.webhookUrl) {
        await this.setupWebhook(repo.owner.login, repo.name);
      }

      // 8. Save to database
      if (this.db) {
        await this.saveDeployment(repo, appPath, options);
      }

      return {
        success: true,
        repo: repo.html_url,
        pages: enablePages ? `https://${repo.owner.login}.github.io/${repo.name}/` : null,
        clone: repo.clone_url,
        api: repo.url
      };
    } catch (error) {
      console.error('[GitHubAppPublisher] Error:', error);
      throw error;
    }
  }

  /**
   * Create a GitHub repository
   * @param {string} name - Repo name
   * @param {string} description - Repo description
   * @param {boolean} isPrivate - Private repo?
   * @param {string} username - GitHub username (if forking to user's account)
   * @returns {Promise<object>} - Created repo
   */
  async createRepo(name, description, isPrivate, username) {
    try {
      const repoData = {
        name,
        description,
        private: isPrivate,
        auto_init: false, // We'll push our own initial commit
        has_issues: true,
        has_projects: true,
        has_wiki: false
      };

      // If username provided, create in their account (requires token with appropriate scope)
      const response = username
        ? await this.octokit.repos.createForAuthenticatedUser(repoData)
        : await this.octokit.repos.createForAuthenticatedUser(repoData);

      console.log(`[GitHubAppPublisher] Created repo: ${response.data.full_name}`);

      return response.data;
    } catch (error) {
      if (error.status === 422 && error.message.includes('already exists')) {
        // Repo already exists - fetch it
        const { data: user } = await this.octokit.users.getAuthenticated();
        const ownerName = username || user.login;
        const { data: repo } = await this.octokit.repos.get({
          owner: ownerName,
          repo: name
        });
        console.log(`[GitHubAppPublisher] Repo already exists: ${repo.full_name}`);
        return repo;
      }
      throw error;
    }
  }

  /**
   * Enable GitHub Pages for a repo
   * @param {string} owner - Repo owner
   * @param {string} repo - Repo name
   */
  async enableGitHubPages(owner, repo) {
    try {
      await this.octokit.repos.createPagesSite({
        owner,
        repo,
        source: {
          branch: 'main',
          path: '/'
        }
      });

      console.log(`[GitHubAppPublisher] GitHub Pages enabled`);
    } catch (error) {
      if (error.status === 409) {
        console.log(`[GitHubAppPublisher] GitHub Pages already enabled`);
      } else {
        console.warn(`[GitHubAppPublisher] Failed to enable Pages:`, error.message);
      }
    }
  }

  /**
   * Set up GitHub Actions workflow
   * @param {string} appPath - App directory
   * @param {string} owner - Repo owner
   * @param {string} repo - Repo name
   */
  async setupGitHubActions(appPath, owner, repo) {
    try {
      // Create .github/workflows directory
      const workflowDir = path.join(appPath, '.github', 'workflows');
      await fs.mkdir(workflowDir, { recursive: true });

      // Create deployment workflow
      const workflow = this.generateDeploymentWorkflow();
      await fs.writeFile(
        path.join(workflowDir, 'deploy.yml'),
        workflow
      );

      console.log(`[GitHubAppPublisher] GitHub Actions workflow created`);
    } catch (error) {
      console.warn(`[GitHubAppPublisher] Failed to setup Actions:`, error.message);
    }
  }

  /**
   * Generate GitHub Actions deployment workflow
   * @returns {string} - Workflow YAML
   */
  generateDeploymentWorkflow() {
    return `name: Deploy to GitHub Pages

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: \${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install || echo "No package.json found"

      - name: Build
        run: npm run build || echo "No build script"

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: '.'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
`;
  }

  /**
   * Set up webhook for deployment notifications
   * @param {string} owner - Repo owner
   * @param {string} repo - Repo name
   */
  async setupWebhook(owner, repo) {
    try {
      await this.octokit.repos.createWebhook({
        owner,
        repo,
        config: {
          url: this.webhookUrl,
          content_type: 'json',
          secret: process.env.GITHUB_WEBHOOK_SECRET || 'calos-webhook-secret'
        },
        events: ['push', 'release', 'deployment', 'page_build']
      });

      console.log(`[GitHubAppPublisher] Webhook configured: ${this.webhookUrl}`);
    } catch (error) {
      console.warn(`[GitHubAppPublisher] Failed to setup webhook:`, error.message);
    }
  }

  /**
   * Save deployment to database
   * @param {object} repo - GitHub repo data
   * @param {string} appPath - App path
   * @param {object} options - Deployment options
   */
  async saveDeployment(repo, appPath, options) {
    try {
      await this.db.query(
        `INSERT INTO app_deployments (
          app_name, repo_url, pages_url, clone_url, api_url,
          is_private, app_path, metadata, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())`,
        [
          options.name,
          repo.html_url,
          `https://${repo.owner.login}.github.io/${repo.name}/`,
          repo.clone_url,
          repo.url,
          options.private || false,
          appPath,
          JSON.stringify({
            owner: repo.owner.login,
            repo: repo.name,
            description: repo.description,
            created_at: repo.created_at
          })
        ]
      );

      console.log(`[GitHubAppPublisher] Deployment saved to database`);
    } catch (error) {
      console.warn(`[GitHubAppPublisher] Failed to save deployment:`, error.message);
    }
  }

  /**
   * Fork a repo to user's account (for anonymous distribution)
   * @param {string} owner - Original repo owner
   * @param {string} repo - Original repo name
   * @param {string} userToken - User's GitHub token
   * @returns {Promise<object>} - Forked repo
   */
  async forkToUser(owner, repo, userToken) {
    try {
      const userOctokit = new Octokit({ auth: userToken });

      const { data: fork } = await userOctokit.repos.createFork({
        owner,
        repo
      });

      console.log(`[GitHubAppPublisher] Forked to: ${fork.full_name}`);

      return fork;
    } catch (error) {
      console.error('[GitHubAppPublisher] Fork failed:', error);
      throw error;
    }
  }

  /**
   * Get deployment status
   * @param {string} owner - Repo owner
   * @param {string} repo - Repo name
   * @returns {Promise<object>} - Deployment status
   */
  async getDeploymentStatus(owner, repo) {
    try {
      const { data: deployments } = await this.octokit.repos.listDeployments({
        owner,
        repo,
        per_page: 1
      });

      if (deployments.length === 0) {
        return { status: 'not_deployed' };
      }

      const latestDeployment = deployments[0];

      const { data: statuses } = await this.octokit.repos.listDeploymentStatuses({
        owner,
        repo,
        deployment_id: latestDeployment.id,
        per_page: 1
      });

      return {
        status: statuses[0]?.state || 'unknown',
        url: statuses[0]?.target_url || latestDeployment.payload?.web_url,
        created_at: latestDeployment.created_at,
        updated_at: statuses[0]?.created_at
      };
    } catch (error) {
      console.error('[GitHubAppPublisher] Failed to get status:', error);
      return { status: 'error', error: error.message };
    }
  }
}

module.exports = GitHubAppPublisher;
