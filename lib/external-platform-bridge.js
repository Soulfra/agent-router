/**
 * External Platform Bridge
 *
 * Connects your domain ecosystem to external platforms (Twitter/X, LinkedIn, Medium, Dev.to, Reddit, Discord)
 * Enables posting content generated by Cal Riven and Multi-Brand Poster to the broader web.
 *
 * Features:
 * - Multi-platform posting (Twitter, LinkedIn, Medium, Dev.to, Reddit, Discord)
 * - Engagement tracking (likes, shares, comments)
 * - Rate limiting per platform
 * - Retry logic with exponential backoff
 * - Cross-posting with format adaptation
 * - Analytics and performance tracking
 */

const axios = require('axios');
const EventEmitter = require('events');
const crypto = require('crypto');

class ExternalPlatformBridge extends EventEmitter {
  constructor({ db, credentials = null }) {
    super();

    this.db = db;
    this.credentials = credentials || new Map();

    // Platform configurations
    this.platforms = {
      twitter: {
        name: 'Twitter/X',
        baseUrl: 'https://api.twitter.com/2',
        rateLimit: 50, // requests per 15 minutes
        charLimit: 280,
        mediaSupported: true
      },
      linkedin: {
        name: 'LinkedIn',
        baseUrl: 'https://api.linkedin.com/v2',
        rateLimit: 100, // requests per day
        charLimit: 3000,
        mediaSupported: true
      },
      medium: {
        name: 'Medium',
        baseUrl: 'https://api.medium.com/v1',
        rateLimit: 1000, // requests per day
        charLimit: null, // no limit
        mediaSupported: true
      },
      devto: {
        name: 'Dev.to',
        baseUrl: 'https://dev.to/api',
        rateLimit: 10, // requests per minute
        charLimit: null,
        mediaSupported: true
      },
      reddit: {
        name: 'Reddit',
        baseUrl: 'https://oauth.reddit.com',
        rateLimit: 60, // requests per minute
        charLimit: 40000, // self posts
        mediaSupported: true
      },
      discord: {
        name: 'Discord',
        baseUrl: null, // uses webhooks
        rateLimit: 30, // messages per minute
        charLimit: 2000,
        mediaSupported: true
      }
    };

    // Rate limit tracking
    this.rateLimits = new Map();

    // Post history
    this.postHistory = new Map();

    // Stats
    this.stats = {
      totalPosts: 0,
      successfulPosts: 0,
      failedPosts: 0,
      byPlatform: {}
    };

    console.log('[ExternalPlatformBridge] Initialized with', Object.keys(this.platforms).length, 'platforms');
  }

  /**
   * Load platform credentials from database
   */
  async loadCredentials() {
    try {
      const result = await this.db.query(
        `SELECT platform, credentials_data, active
         FROM external_platform_credentials
         WHERE active = true`
      );

      for (const row of result.rows) {
        this.credentials.set(row.platform, JSON.parse(row.credentials_data));
      }

      console.log(`[ExternalPlatformBridge] Loaded credentials for ${this.credentials.size} platforms`);
      return this.credentials;
    } catch (error) {
      console.error('[ExternalPlatformBridge] Error loading credentials:', error);
      return this.credentials;
    }
  }

  /**
   * Post content to external platform
   */
  async post({ platform, content, brand = null, media = [], metadata = {} }) {
    const postId = crypto.randomUUID();
    const startTime = Date.now();

    try {
      // Check if platform is supported
      if (!this.platforms[platform]) {
        throw new Error(`Unsupported platform: ${platform}`);
      }

      // Check credentials
      if (!this.credentials.has(platform)) {
        throw new Error(`No credentials configured for ${platform}`);
      }

      // Check rate limit
      if (this.isRateLimited(platform)) {
        const waitTime = this.getRateLimitWaitTime(platform);
        throw new Error(`Rate limited. Wait ${Math.ceil(waitTime / 1000)}s`);
      }

      // Adapt content for platform
      const adaptedContent = this.adaptContentForPlatform(content, platform);

      // Post to platform
      let result;
      switch (platform) {
        case 'twitter':
          result = await this.postToTwitter(adaptedContent, media, metadata);
          break;
        case 'linkedin':
          result = await this.postToLinkedIn(adaptedContent, media, metadata);
          break;
        case 'medium':
          result = await this.postToMedium(adaptedContent, media, metadata);
          break;
        case 'devto':
          result = await this.postToDevTo(adaptedContent, media, metadata);
          break;
        case 'reddit':
          result = await this.postToReddit(adaptedContent, media, metadata);
          break;
        case 'discord':
          result = await this.postToDiscord(adaptedContent, media, metadata);
          break;
        default:
          throw new Error(`Platform handler not implemented: ${platform}`);
      }

      const endTime = Date.now();
      const responseTime = endTime - startTime;

      // Track rate limit
      this.trackRateLimit(platform);

      // Store post history
      const postRecord = {
        postId,
        platform,
        brand,
        content: adaptedContent,
        externalId: result.id,
        externalUrl: result.url,
        postedAt: new Date(),
        responseTime,
        metadata
      };

      this.postHistory.set(postId, postRecord);

      // Store in database
      if (this.db) {
        await this.savePostToDatabase(postRecord);
      }

      // Update stats
      this.stats.totalPosts++;
      this.stats.successfulPosts++;
      if (!this.stats.byPlatform[platform]) {
        this.stats.byPlatform[platform] = { posts: 0, successes: 0, failures: 0 };
      }
      this.stats.byPlatform[platform].posts++;
      this.stats.byPlatform[platform].successes++;

      // Emit event
      this.emit('post_success', {
        postId,
        platform,
        brand,
        externalUrl: result.url,
        responseTime
      });

      console.log(`[ExternalPlatformBridge] ✓ Posted to ${platform}: ${result.url}`);

      return {
        success: true,
        postId,
        platform,
        externalId: result.id,
        externalUrl: result.url,
        responseTime
      };

    } catch (error) {
      const endTime = Date.now();
      const responseTime = endTime - startTime;

      // Update stats
      this.stats.totalPosts++;
      this.stats.failedPosts++;
      if (!this.stats.byPlatform[platform]) {
        this.stats.byPlatform[platform] = { posts: 0, successes: 0, failures: 0 };
      }
      this.stats.byPlatform[platform].posts++;
      this.stats.byPlatform[platform].failures++;

      // Emit event
      this.emit('post_error', {
        postId,
        platform,
        brand,
        error: error.message,
        responseTime
      });

      console.error(`[ExternalPlatformBridge] ✗ Failed to post to ${platform}:`, error.message);

      return {
        success: false,
        postId,
        platform,
        error: error.message,
        responseTime
      };
    }
  }

  /**
   * Cross-post to multiple platforms
   */
  async crossPost({ content, platforms = [], brand = null, media = [], metadata = {} }) {
    const results = await Promise.allSettled(
      platforms.map(platform =>
        this.post({ platform, content, brand, media, metadata })
      )
    );

    const summary = {
      total: platforms.length,
      successful: 0,
      failed: 0,
      results: []
    };

    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const platform = platforms[i];

      if (result.status === 'fulfilled' && result.value.success) {
        summary.successful++;
        summary.results.push({
          platform,
          success: true,
          url: result.value.externalUrl
        });
      } else {
        summary.failed++;
        summary.results.push({
          platform,
          success: false,
          error: result.reason || result.value.error
        });
      }
    }

    console.log(`[ExternalPlatformBridge] Cross-posted to ${platforms.length} platforms: ${summary.successful} succeeded, ${summary.failed} failed`);

    return summary;
  }

  /**
   * Adapt content for platform constraints
   */
  adaptContentForPlatform(content, platform) {
    const config = this.platforms[platform];

    // Handle character limits
    if (config.charLimit && content.length > config.charLimit) {
      const truncated = content.substring(0, config.charLimit - 3) + '...';
      console.log(`[ExternalPlatformBridge] Truncated content for ${platform}: ${content.length} → ${truncated.length} chars`);
      return truncated;
    }

    // Platform-specific adaptations
    switch (platform) {
      case 'twitter':
        // Add hashtags for Twitter
        return content;

      case 'linkedin':
        // More professional tone for LinkedIn
        return content;

      case 'devto':
        // Add front matter for Dev.to
        return content;

      default:
        return content;
    }
  }

  /**
   * Post to Twitter/X
   */
  async postToTwitter(content, media, metadata) {
    const creds = this.credentials.get('twitter');

    try {
      const response = await axios.post(
        'https://api.twitter.com/2/tweets',
        { text: content },
        {
          headers: {
            'Authorization': `Bearer ${creds.bearerToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      const tweetId = response.data.data.id;
      const tweetUrl = `https://twitter.com/i/web/status/${tweetId}`;

      return {
        id: tweetId,
        url: tweetUrl,
        platform: 'twitter'
      };
    } catch (error) {
      throw new Error(`Twitter API error: ${error.response?.data?.detail || error.message}`);
    }
  }

  /**
   * Post to LinkedIn
   */
  async postToLinkedIn(content, media, metadata) {
    const creds = this.credentials.get('linkedin');

    try {
      const response = await axios.post(
        'https://api.linkedin.com/v2/ugcPosts',
        {
          author: `urn:li:person:${creds.personId}`,
          lifecycleState: 'PUBLISHED',
          specificContent: {
            'com.linkedin.ugc.ShareContent': {
              shareCommentary: {
                text: content
              },
              shareMediaCategory: 'NONE'
            }
          },
          visibility: {
            'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC'
          }
        },
        {
          headers: {
            'Authorization': `Bearer ${creds.accessToken}`,
            'Content-Type': 'application/json',
            'X-Restli-Protocol-Version': '2.0.0'
          }
        }
      );

      const postId = response.data.id;
      const postUrl = `https://www.linkedin.com/feed/update/${postId}`;

      return {
        id: postId,
        url: postUrl,
        platform: 'linkedin'
      };
    } catch (error) {
      throw new Error(`LinkedIn API error: ${error.response?.data?.message || error.message}`);
    }
  }

  /**
   * Post to Medium
   */
  async postToMedium(content, media, metadata) {
    const creds = this.credentials.get('medium');

    try {
      const response = await axios.post(
        `https://api.medium.com/v1/users/${creds.userId}/posts`,
        {
          title: metadata.title || 'Untitled',
          contentFormat: 'markdown',
          content,
          publishStatus: 'public'
        },
        {
          headers: {
            'Authorization': `Bearer ${creds.accessToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      return {
        id: response.data.data.id,
        url: response.data.data.url,
        platform: 'medium'
      };
    } catch (error) {
      throw new Error(`Medium API error: ${error.response?.data?.errors?.[0]?.message || error.message}`);
    }
  }

  /**
   * Post to Dev.to
   */
  async postToDevTo(content, media, metadata) {
    const creds = this.credentials.get('devto');

    try {
      const response = await axios.post(
        'https://dev.to/api/articles',
        {
          article: {
            title: metadata.title || 'Untitled',
            body_markdown: content,
            published: true,
            tags: metadata.tags || []
          }
        },
        {
          headers: {
            'api-key': creds.apiKey,
            'Content-Type': 'application/json'
          }
        }
      );

      return {
        id: response.data.id,
        url: response.data.url,
        platform: 'devto'
      };
    } catch (error) {
      throw new Error(`Dev.to API error: ${error.response?.data?.error || error.message}`);
    }
  }

  /**
   * Post to Reddit
   */
  async postToReddit(content, media, metadata) {
    const creds = this.credentials.get('reddit');
    const subreddit = metadata.subreddit || 'test';

    try {
      const response = await axios.post(
        'https://oauth.reddit.com/api/submit',
        new URLSearchParams({
          sr: subreddit,
          kind: 'self',
          title: metadata.title || 'Untitled',
          text: content
        }),
        {
          headers: {
            'Authorization': `Bearer ${creds.accessToken}`,
            'User-Agent': 'CalOS-Bridge/1.0'
          }
        }
      );

      const postUrl = response.data.json.data.url;
      const postId = response.data.json.data.id;

      return {
        id: postId,
        url: postUrl,
        platform: 'reddit'
      };
    } catch (error) {
      throw new Error(`Reddit API error: ${error.response?.data?.message || error.message}`);
    }
  }

  /**
   * Post to Discord via webhook
   */
  async postToDiscord(content, media, metadata) {
    const creds = this.credentials.get('discord');

    try {
      const response = await axios.post(
        creds.webhookUrl,
        {
          content,
          username: metadata.username || 'CalOS Bot',
          avatar_url: metadata.avatarUrl || null
        }
      );

      return {
        id: crypto.randomUUID(),
        url: creds.webhookUrl,
        platform: 'discord'
      };
    } catch (error) {
      throw new Error(`Discord webhook error: ${error.response?.data?.message || error.message}`);
    }
  }

  /**
   * Track engagement (likes, shares, comments)
   */
  async trackEngagement(postId) {
    const post = this.postHistory.get(postId);
    if (!post) {
      throw new Error(`Post not found: ${postId}`);
    }

    // Fetch engagement metrics from platform API
    // Implementation depends on platform

    return {
      postId,
      platform: post.platform,
      likes: 0,
      shares: 0,
      comments: 0,
      views: 0
    };
  }

  /**
   * Rate limiting
   */
  isRateLimited(platform) {
    const key = `ratelimit_${platform}`;
    const limit = this.rateLimits.get(key);

    if (!limit) return false;

    return limit.count >= this.platforms[platform].rateLimit && Date.now() < limit.resetTime;
  }

  trackRateLimit(platform) {
    const key = `ratelimit_${platform}`;
    const limit = this.rateLimits.get(key) || { count: 0, resetTime: Date.now() + 60000 };

    if (Date.now() >= limit.resetTime) {
      limit.count = 1;
      limit.resetTime = Date.now() + 60000;
    } else {
      limit.count++;
    }

    this.rateLimits.set(key, limit);
  }

  getRateLimitWaitTime(platform) {
    const key = `ratelimit_${platform}`;
    const limit = this.rateLimits.get(key);
    return limit ? limit.resetTime - Date.now() : 0;
  }

  /**
   * Save post to database
   */
  async savePostToDatabase(postRecord) {
    try {
      await this.db.query(
        `INSERT INTO external_platform_posts (
          post_id, platform, brand, content, external_id, external_url,
          posted_at, response_time, metadata
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
        [
          postRecord.postId,
          postRecord.platform,
          postRecord.brand,
          postRecord.content,
          postRecord.externalId,
          postRecord.externalUrl,
          postRecord.postedAt,
          postRecord.responseTime,
          JSON.stringify(postRecord.metadata)
        ]
      );
    } catch (error) {
      console.error('[ExternalPlatformBridge] Error saving post to database:', error);
    }
  }

  /**
   * Get stats
   */
  getStats() {
    return {
      ...this.stats,
      successRate: this.stats.totalPosts > 0
        ? ((this.stats.successfulPosts / this.stats.totalPosts) * 100).toFixed(2) + '%'
        : '100%'
    };
  }

  /**
   * Get post history
   */
  getPostHistory({ limit = 50, platform = null } = {}) {
    let posts = Array.from(this.postHistory.values());

    if (platform) {
      posts = posts.filter(p => p.platform === platform);
    }

    posts.sort((a, b) => b.postedAt - a.postedAt);

    return posts.slice(0, limit);
  }
}

module.exports = ExternalPlatformBridge;
