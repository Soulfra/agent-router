-- Bucket Artifacts Storage
-- Persistent storage for AI-generated code/artifacts per bucket/domain
--
-- Key insight: Bridge the gap between buckets, domains, and generated code
-- Links: prompt → reasoning → generated code → bucket → domain
-- Enables: "Show me all code generated by bucket-code for domain X"

-- ============================================================================
-- Bucket Artifacts (AI-Generated Code)
-- ============================================================================

CREATE TABLE IF NOT EXISTS bucket_artifacts (
  artifact_id TEXT PRIMARY KEY,

  -- Which bucket generated this
  bucket_id TEXT NOT NULL REFERENCES bucket_instances(bucket_id) ON DELETE CASCADE,

  -- Domain context (inherited from bucket, but denormalized for fast queries)
  domain_context TEXT, -- 'code', 'creative', 'reasoning', 'fact', 'simple'
  domain_url TEXT,     -- Associated domain from portfolio

  -- Artifact classification
  artifact_type TEXT NOT NULL, -- 'snippet', 'function', 'class', 'component', 'page', 'api', 'config', 'svg', 'animation'
  language TEXT,               -- 'javascript', 'python', 'lua', 'html', 'css', 'svg', 'markdown'
  framework TEXT,              -- 'react', 'vue', 'express', 'flask', null

  -- The generated code/content
  code TEXT NOT NULL,
  code_hash TEXT,              -- SHA-256 hash for deduplication

  -- Metadata
  artifact_name TEXT,          -- Human-readable name
  description TEXT,            -- AI-generated or user-provided
  tags TEXT[],                 -- ['authentication', 'api', 'rest']

  -- Original context (THE KEY LINKAGE)
  original_prompt TEXT NOT NULL,     -- The user's original request
  reasoning_log_id INTEGER REFERENCES bucket_reasoning_log(reasoning_id), -- WHY this was generated
  request_id TEXT,             -- Link to original request
  parent_artifact_id TEXT REFERENCES bucket_artifacts(artifact_id), -- If this is a refinement

  -- Model/wrapper used
  model_id TEXT NOT NULL,      -- Which model generated this
  wrapper_name TEXT,           -- Which wrapper config was used
  model_parameters JSONB,      -- {temperature: 0.7, max_tokens: 2000}

  -- Quality metrics
  user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),
  times_used INTEGER DEFAULT 0,
  times_modified INTEGER DEFAULT 0,
  success_score REAL,          -- Auto-calculated quality score

  -- Versioning
  version INTEGER DEFAULT 1,
  is_current BOOLEAN DEFAULT true,
  superseded_by TEXT REFERENCES bucket_artifacts(artifact_id),

  -- File info (if saved to filesystem)
  file_path TEXT,              -- Path in MinIO or filesystem
  file_size INTEGER,           -- Bytes
  mime_type TEXT,              -- 'text/javascript', 'image/svg+xml'

  -- Status
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'archived', 'deprecated', 'failed')),
  visibility TEXT DEFAULT 'private' CHECK (visibility IN ('private', 'team', 'public')),

  -- Usage tracking
  last_used_at TIMESTAMPTZ,
  last_modified_at TIMESTAMPTZ,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by TEXT,             -- User or 'system'
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_bucket_artifacts_bucket ON bucket_artifacts(bucket_id);
CREATE INDEX idx_bucket_artifacts_domain ON bucket_artifacts(domain_context);
CREATE INDEX idx_bucket_artifacts_type ON bucket_artifacts(artifact_type);
CREATE INDEX idx_bucket_artifacts_language ON bucket_artifacts(language);
CREATE INDEX idx_bucket_artifacts_hash ON bucket_artifacts(code_hash); -- Deduplication
CREATE INDEX idx_bucket_artifacts_tags ON bucket_artifacts USING GIN(tags);
CREATE INDEX idx_bucket_artifacts_status ON bucket_artifacts(status, is_current);
CREATE INDEX idx_bucket_artifacts_created ON bucket_artifacts(created_at DESC);
CREATE INDEX idx_bucket_artifacts_parent ON bucket_artifacts(parent_artifact_id) WHERE parent_artifact_id IS NOT NULL;

-- ============================================================================
-- Artifact Dependencies
-- Track imports, dependencies, related artifacts
-- ============================================================================

CREATE TABLE IF NOT EXISTS artifact_dependencies (
  id SERIAL PRIMARY KEY,

  -- Which artifact
  artifact_id TEXT NOT NULL REFERENCES bucket_artifacts(artifact_id) ON DELETE CASCADE,

  -- What it depends on
  depends_on_artifact_id TEXT REFERENCES bucket_artifacts(artifact_id) ON DELETE CASCADE,
  depends_on_external TEXT,    -- External library: 'react@18.2.0', 'lodash@4.17.21'

  -- Dependency type
  dependency_type TEXT NOT NULL, -- 'import', 'extends', 'requires', 'calls', 'references'

  -- Context
  required BOOLEAN DEFAULT true,
  optional_context TEXT,       -- Why this dependency exists

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_artifact_deps_artifact ON artifact_dependencies(artifact_id);
CREATE INDEX idx_artifact_deps_depends ON artifact_dependencies(depends_on_artifact_id);
CREATE INDEX idx_artifact_deps_external ON artifact_dependencies(depends_on_external);

-- ============================================================================
-- Artifact Usage Log
-- Track when/how artifacts are used
-- ============================================================================

CREATE TABLE IF NOT EXISTS artifact_usage_log (
  id SERIAL PRIMARY KEY,

  -- Which artifact
  artifact_id TEXT NOT NULL REFERENCES bucket_artifacts(artifact_id) ON DELETE CASCADE,

  -- Usage context
  used_by TEXT,                -- User ID or system component
  usage_type TEXT NOT NULL,    -- 'copy', 'modify', 'reference', 'execute', 'embed'

  -- Where used
  used_in_request_id TEXT,
  used_in_session_id TEXT,

  -- Result
  success BOOLEAN DEFAULT true,
  error_message TEXT,

  -- Feedback
  user_feedback TEXT,
  user_rating INTEGER CHECK (user_rating >= 1 AND user_rating <= 5),

  timestamp TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_artifact_usage_artifact ON artifact_usage_log(artifact_id);
CREATE INDEX idx_artifact_usage_timestamp ON artifact_usage_log(timestamp DESC);
CREATE INDEX idx_artifact_usage_user ON artifact_usage_log(used_by);

-- ============================================================================
-- Artifact Collections (Grouping related artifacts)
-- ============================================================================

CREATE TABLE IF NOT EXISTS artifact_collections (
  collection_id TEXT PRIMARY KEY,

  -- Collection metadata
  collection_name TEXT NOT NULL,
  collection_slug TEXT UNIQUE NOT NULL,
  description TEXT,

  -- Domain/bucket
  bucket_id TEXT REFERENCES bucket_instances(bucket_id) ON DELETE CASCADE,
  domain_context TEXT,

  -- Organization
  tags TEXT[],
  category TEXT,               -- 'components', 'apis', 'utilities', 'examples'

  -- Visibility
  visibility TEXT DEFAULT 'private' CHECK (visibility IN ('private', 'team', 'public')),

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_artifact_collections_bucket ON artifact_collections(bucket_id);
CREATE INDEX idx_artifact_collections_domain ON artifact_collections(domain_context);
CREATE INDEX idx_artifact_collections_slug ON artifact_collections(collection_slug);

-- Link artifacts to collections (many-to-many)
CREATE TABLE IF NOT EXISTS artifact_collection_members (
  id SERIAL PRIMARY KEY,

  collection_id TEXT NOT NULL REFERENCES artifact_collections(collection_id) ON DELETE CASCADE,
  artifact_id TEXT NOT NULL REFERENCES bucket_artifacts(artifact_id) ON DELETE CASCADE,

  -- Order/position in collection
  position INTEGER DEFAULT 0,

  -- Metadata
  added_at TIMESTAMPTZ DEFAULT NOW(),
  added_by TEXT,

  UNIQUE(collection_id, artifact_id)
);

CREATE INDEX idx_collection_members_collection ON artifact_collection_members(collection_id, position);
CREATE INDEX idx_collection_members_artifact ON artifact_collection_members(artifact_id);

-- ============================================================================
-- Views for Common Queries
-- ============================================================================

-- Recently generated artifacts per bucket
CREATE OR REPLACE VIEW recent_bucket_artifacts AS
SELECT
  ba.artifact_id,
  ba.bucket_id,
  bi.bucket_name,
  ba.domain_context,
  ba.artifact_type,
  ba.artifact_name,
  ba.language,
  ba.times_used,
  ba.user_rating,
  ba.created_at
FROM bucket_artifacts ba
JOIN bucket_instances bi ON ba.bucket_id = bi.bucket_id
WHERE ba.status = 'active' AND ba.is_current = true
ORDER BY ba.created_at DESC
LIMIT 100;

-- Most used artifacts per domain
CREATE OR REPLACE VIEW popular_domain_artifacts AS
SELECT
  ba.domain_context,
  ba.artifact_type,
  ba.artifact_id,
  ba.artifact_name,
  ba.language,
  ba.times_used,
  AVG(ba.user_rating) as avg_rating,
  COUNT(DISTINCT aul.id) as usage_count
FROM bucket_artifacts ba
LEFT JOIN artifact_usage_log aul ON ba.artifact_id = aul.artifact_id
WHERE ba.status = 'active' AND ba.is_current = true
GROUP BY ba.domain_context, ba.artifact_type, ba.artifact_id, ba.artifact_name, ba.language, ba.times_used
HAVING ba.times_used > 0
ORDER BY ba.times_used DESC, avg_rating DESC NULLS LAST
LIMIT 50;

-- Artifact dependencies graph
CREATE OR REPLACE VIEW artifact_dependency_graph AS
SELECT
  ba.artifact_id,
  ba.artifact_name,
  ba.artifact_type,
  array_agg(DISTINCT ad.depends_on_artifact_id) FILTER (WHERE ad.depends_on_artifact_id IS NOT NULL) as internal_deps,
  array_agg(DISTINCT ad.depends_on_external) FILTER (WHERE ad.depends_on_external IS NOT NULL) as external_deps
FROM bucket_artifacts ba
LEFT JOIN artifact_dependencies ad ON ba.artifact_id = ad.artifact_id
WHERE ba.status = 'active' AND ba.is_current = true
GROUP BY ba.artifact_id, ba.artifact_name, ba.artifact_type;

-- ============================================================================
-- Triggers
-- ============================================================================

-- Update timestamps
CREATE TRIGGER update_bucket_artifacts_updated_at
  BEFORE UPDATE ON bucket_artifacts
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_artifact_collections_updated_at
  BEFORE UPDATE ON artifact_collections
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Increment times_used on artifact usage
CREATE OR REPLACE FUNCTION increment_artifact_usage()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.success THEN
    UPDATE bucket_artifacts
    SET
      times_used = times_used + 1,
      last_used_at = NEW.timestamp
    WHERE artifact_id = NEW.artifact_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_increment_artifact_usage
  AFTER INSERT ON artifact_usage_log
  FOR EACH ROW EXECUTE FUNCTION increment_artifact_usage();

-- ============================================================================
-- Comments
-- ============================================================================

COMMENT ON TABLE bucket_artifacts IS 'AI-generated code artifacts with full context: prompt → reasoning → code → bucket → domain';
COMMENT ON TABLE artifact_dependencies IS 'Track imports and dependencies between artifacts';
COMMENT ON TABLE artifact_usage_log IS 'Track when and how artifacts are used';
COMMENT ON TABLE artifact_collections IS 'Group related artifacts into collections (components, APIs, utilities)';
COMMENT ON COLUMN bucket_artifacts.original_prompt IS 'The user prompt that led to this artifact being generated';
COMMENT ON COLUMN bucket_artifacts.reasoning_log_id IS 'WHY this artifact was generated (links to bucket_reasoning_log)';
COMMENT ON COLUMN bucket_artifacts.code_hash IS 'SHA-256 hash for deduplication across buckets';
