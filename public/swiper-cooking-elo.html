<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Recipe ELO Ranker - Find the Best Recipes</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      min-height: 100vh;
      color: #fff;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }

    .header p {
      opacity: 0.9;
      font-size: 1.1em;
    }

    .elo-badge {
      display: inline-block;
      background: rgba(255, 255, 255, 0.2);
      padding: 8px 16px;
      border-radius: 20px;
      margin-top: 10px;
      font-weight: 600;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    .vs-container {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 20px;
      align-items: center;
      margin-bottom: 30px;
    }

    .recipe-card {
      background: white;
      border-radius: 15px;
      padding: 25px;
      color: #333;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }

    .recipe-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
    }

    .recipe-card.winner {
      animation: winPulse 0.5s ease;
    }

    @keyframes winPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .recipe-name {
      font-size: 1.5em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #f5576c;
    }

    .recipe-cuisine {
      font-size: 0.9em;
      color: #888;
      margin-bottom: 15px;
    }

    .recipe-description {
      font-size: 0.95em;
      line-height: 1.5;
      color: #555;
      margin-bottom: 15px;
    }

    .recipe-stats {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #eee;
    }

    .stat {
      flex: 1;
      text-align: center;
    }

    .stat-label {
      font-size: 0.75em;
      color: #888;
      text-transform: uppercase;
    }

    .stat-value {
      font-size: 1.2em;
      font-weight: bold;
      color: #f5576c;
    }

    .elo-rating {
      position: absolute;
      top: -10px;
      right: -10px;
      background: #f5576c;
      color: white;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
    }

    .elo-number {
      font-size: 1.3em;
    }

    .elo-label {
      font-size: 0.6em;
      opacity: 0.9;
    }

    .tier-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: 600;
      margin-top: 8px;
    }

    .vs-separator {
      font-size: 2em;
      font-weight: bold;
      text-align: center;
      opacity: 0.8;
    }

    .prediction {
      text-align: center;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 30px;
    }

    .prediction-text {
      font-size: 0.9em;
      margin-bottom: 10px;
    }

    .probability-bar {
      display: flex;
      height: 30px;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .prob-a, .prob-b {
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 0.85em;
      transition: width 0.3s ease;
    }

    .prob-a {
      background: #10b981;
    }

    .prob-b {
      background: #ef4444;
    }

    .leaderboard {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      margin-top: 30px;
    }

    .leaderboard h2 {
      margin-bottom: 15px;
      text-align: center;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      gap: 15px;
      background: rgba(255, 255, 255, 0.1);
      padding: 12px;
      border-radius: 10px;
      margin-bottom: 10px;
    }

    .rank {
      font-size: 1.5em;
      font-weight: bold;
      min-width: 40px;
      text-align: center;
    }

    .rank.gold { color: #fbbf24; }
    .rank.silver { color: #d1d5db; }
    .rank.bronze { color: #f59e0b; }

    .item-info {
      flex: 1;
    }

    .item-name {
      font-weight: 600;
      margin-bottom: 3px;
    }

    .item-record {
      font-size: 0.85em;
      opacity: 0.8;
    }

    .item-rating {
      font-size: 1.3em;
      font-weight: bold;
      color: #fbbf24;
    }

    .match-count {
      text-align: center;
      margin-top: 20px;
      font-size: 0.9em;
      opacity: 0.8;
    }

    .rate-limit-status {
      text-align: center;
      margin-top: 10px;
      font-size: 0.85em;
      opacity: 0.9;
    }

    .tier-badge-small {
      display: inline-block;
      background: rgba(255, 255, 255, 0.15);
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.9em;
      margin-left: 5px;
    }

    .loading {
      text-align: center;
      padding: 40px;
      font-size: 1.2em;
    }

    /* ============================================
       PAYMENT WALL MODAL
       ============================================ */

    .payment-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .payment-modal.show {
      display: flex;
    }

    .payment-modal-content {
      background: white;
      border-radius: 20px;
      padding: 40px;
      max-width: 500px;
      width: 100%;
      text-align: center;
      position: relative;
      animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .payment-modal h2 {
      color: #2d3436;
      font-size: 28px;
      margin-bottom: 15px;
    }

    .payment-modal p {
      color: #636e72;
      font-size: 16px;
      margin-bottom: 25px;
      line-height: 1.5;
    }

    .payment-modal .price {
      font-size: 48px;
      font-weight: bold;
      background: linear-gradient(135deg, #f093fb, #f5576c);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }

    .payment-modal .price-detail {
      color: #888;
      font-size: 14px;
      margin-bottom: 30px;
    }

    .payment-modal .features {
      text-align: left;
      background: #f8f9fa;
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 25px;
    }

    .payment-modal .feature {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      color: #2d3436;
    }

    .payment-modal .feature:last-child {
      margin-bottom: 0;
    }

    .payment-modal .feature-icon {
      color: #00b894;
      font-size: 20px;
    }

    .payment-modal .btn-upgrade {
      background: linear-gradient(135deg, #f093fb, #f5576c);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 18px 40px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-bottom: 15px;
      transition: all 0.3s;
    }

    .payment-modal .btn-upgrade:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(245, 87, 108, 0.4);
    }

    .payment-modal .btn-close {
      background: #e9ecef;
      color: #636e72;
      border: none;
      border-radius: 10px;
      padding: 12px 30px;
      font-size: 14px;
      cursor: pointer;
      width: 100%;
      transition: all 0.3s;
    }

    .payment-modal .btn-close:hover {
      background: #dee2e6;
    }

    /* ============================================
       MOBILE RESPONSIVE DESIGN
       ============================================ */

    /* Mobile phones (portrait) - Stack vertically */
    @media (max-width: 767px) {
      body {
        padding: 10px;
      }

      .container {
        max-width: 100%;
        padding: 0 5px;
      }

      .header h1 {
        font-size: 1.8em;
        margin-bottom: 8px;
      }

      .header p {
        font-size: 0.95em;
      }

      .elo-badge {
        padding: 6px 12px;
        font-size: 0.9em;
      }

      .rate-limit-status {
        font-size: 0.8em;
      }

      /* Stack cards vertically on mobile */
      .vs-container {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      /* Hide VS separator on mobile */
      .vs-separator {
        display: none;
      }

      .recipe-card {
        padding: 20px;
      }

      .recipe-name {
        font-size: 1.3em;
      }

      .recipe-description {
        font-size: 0.9em;
      }

      .elo-rating {
        width: 55px;
        height: 55px;
      }

      .elo-number {
        font-size: 1.1em;
      }

      .prediction {
        padding: 12px;
        margin-bottom: 20px;
      }

      .leaderboard {
        padding: 15px;
        margin-top: 20px;
      }

      .leaderboard h2 {
        font-size: 1.3em;
      }

      .leaderboard-item {
        gap: 10px;
        padding: 10px;
      }

      .rank {
        font-size: 1.2em;
        min-width: 35px;
      }

      .item-name {
        font-size: 0.95em;
      }

      .item-record {
        font-size: 0.8em;
      }

      .item-rating {
        font-size: 1.1em;
      }
    }

    /* Tablets (portrait) */
    @media (min-width: 768px) and (max-width: 1024px) {
      .container {
        max-width: 720px;
      }

      .header h1 {
        font-size: 2.2em;
      }

      /* Keep side-by-side on tablets but adjust spacing */
      .vs-container {
        gap: 15px;
      }

      .recipe-card {
        padding: 20px;
      }
    }

    /* Large tablets and small desktops */
    @media (min-width: 1025px) and (max-width: 1440px) {
      .container {
        max-width: 900px;
      }
    }

    /* Large desktops */
    @media (min-width: 1441px) {
      .container {
        max-width: 1200px;
      }

      .vs-container {
        gap: 30px;
      }
    }

    /* Landscape phones - keep vertical stack but optimize spacing */
    @media (max-width: 767px) and (orientation: landscape) {
      .header h1 {
        font-size: 1.5em;
      }

      .header {
        margin-bottom: 20px;
      }

      .leaderboard {
        margin-top: 15px;
      }
    }

    /* Touch device optimization */
    @media (hover: none) and (pointer: coarse) {
      .recipe-card {
        /* Ensure minimum touch target size (44x44px) */
        min-height: 44px;
      }

      /* Remove hover effects on touch devices */
      .recipe-card:hover {
        transform: none;
      }

      /* Add active state for touch feedback */
      .recipe-card:active {
        transform: scale(0.98);
        opacity: 0.9;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üç≥ Recipe ELO Ranker</h1>
      <p>Rank recipes like Chess.com ranks players</p>
      <div class="elo-badge" id="matchCount">Match #0</div>
      <div class="rate-limit-status" id="rateLimitStatus">Loading...</div>
    </div>

    <div class="prediction" id="prediction" style="display: none;">
      <div class="prediction-text">Predicted winner probability:</div>
      <div class="probability-bar">
        <div class="prob-a" id="probA">50%</div>
        <div class="prob-b" id="probB">50%</div>
      </div>
    </div>

    <div class="vs-container" id="vsContainer">
      <div class="loading">Loading recipes...</div>
    </div>

    <div class="leaderboard">
      <h2>üèÜ Top Recipes</h2>
      <div id="leaderboardList">
        <div class="loading">No rankings yet</div>
      </div>
      <div class="match-count" id="totalMatches">Total matches: 0</div>
    </div>
  </div>

  <!-- Payment Wall Modal -->
  <div class="payment-modal" id="paymentModal">
    <div class="payment-modal-content">
      <h2>üéâ You've Used Your Free Swipes!</h2>
      <p>Upgrade to Premium to get unlimited recipe rankings and save your favorites.</p>

      <div class="price">$4.99</div>
      <div class="price-detail">per month, cancel anytime</div>

      <div class="features">
        <div class="feature">
          <span class="feature-icon">‚úì</span>
          <span>Unlimited recipe swipes</span>
        </div>
        <div class="feature">
          <span class="feature-icon">‚úì</span>
          <span>Save your top recipes</span>
        </div>
        <div class="feature">
          <span class="feature-icon">‚úì</span>
          <span>Export your ELO rankings</span>
        </div>
        <div class="feature">
          <span class="feature-icon">‚úì</span>
          <span>Advanced filtering & search</span>
        </div>
        <div class="feature">
          <span class="feature-icon">‚úì</span>
          <span>Priority recipe additions</span>
        </div>
      </div>

      <button class="btn-upgrade" onclick="upgradeToPremium()">Upgrade to Premium</button>
      <button class="btn-close" onclick="closePaymentModal()">Maybe Later</button>
    </div>
  </div>

  <script src="../lib/analytics.js"></script>
  <script src="../lib/elo-calculator.js"></script>
  <script>
    const API_URL = 'http://localhost:5001/api/elo';
    let currentMatchup = null;
    let matchNumber = 0;
    let eloCalc = null;
    let voteStartTime = null;

    // Free tier limits
    const FREE_SWIPES_PER_DAY = 20;
    let swipesUsedToday = 0;
    let isPremium = false;

    // Device fingerprinting - unique device identification
    async function generateDeviceFingerprint() {
      const components = [
        navigator.userAgent,
        navigator.language,
        navigator.hardwareConcurrency || 0,
        screen.width + 'x' + screen.height,
        screen.colorDepth,
        new Date().getTimezoneOffset(),
        navigator.platform,
        navigator.maxTouchPoints || 0
      ];

      // Canvas fingerprint (GPU rendering differences)
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.textBaseline = 'alphabetic';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText('ELO Fingerprint üç≥', 2, 15);
        ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
        ctx.fillText('ELO Fingerprint üç≥', 4, 17);
        components.push(canvas.toDataURL());
      } catch (e) {
        components.push('canvas_error');
      }

      // Hash all components
      const str = components.join('|');
      const buffer = new TextEncoder().encode(str);
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Session management - persistent across page loads
    let sessionId = localStorage.getItem('elo_session_id');
    let deviceId = localStorage.getItem('elo_device_id');

    if (!sessionId) {
      sessionId = 'web_' + crypto.randomUUID();
      localStorage.setItem('elo_session_id', sessionId);
    }

    // Generate device fingerprint on first visit
    if (!deviceId) {
      generateDeviceFingerprint().then(fp => {
        deviceId = fp;
        localStorage.setItem('elo_device_id', deviceId);
        console.log('üîí Device fingerprint generated:', deviceId.substring(0, 16) + '...');
      });
    } else {
      console.log('üîí Device fingerprint loaded:', deviceId.substring(0, 16) + '...');
    }

    // Sample recipe data
    const SAMPLE_RECIPES = [
      {
        name: "Classic Carbonara",
        cuisine: "Italian",
        description: "Creamy pasta with eggs, pecorino cheese, guanciale, and black pepper",
        difficulty: "Medium",
        time: "20 min"
      },
      {
        name: "Pad Thai",
        cuisine: "Thai",
        description: "Stir-fried rice noodles with shrimp, peanuts, eggs, and tamarind sauce",
        difficulty: "Medium",
        time: "25 min"
      },
      {
        name: "Beef Wellington",
        cuisine: "British",
        description: "Filet of beef coated with mushroom duxelles, wrapped in puff pastry",
        difficulty: "Hard",
        time: "2 hours"
      },
      {
        name: "Chicken Tikka Masala",
        cuisine: "Indian",
        description: "Marinated chicken in spiced tomato cream sauce, served with rice",
        difficulty: "Medium",
        time: "45 min"
      },
      {
        name: "Tacos al Pastor",
        cuisine: "Mexican",
        description: "Marinated pork with pineapple, cilantro, and onions on corn tortillas",
        difficulty: "Easy",
        time: "30 min"
      },
      {
        name: "Ramen Bowl",
        cuisine: "Japanese",
        description: "Rich pork broth with noodles, chashu, soft-boiled egg, and green onions",
        difficulty: "Hard",
        time: "3 hours"
      },
      {
        name: "Margherita Pizza",
        cuisine: "Italian",
        description: "Simple pizza with tomato sauce, fresh mozzarella, basil, and olive oil",
        difficulty: "Easy",
        time: "30 min"
      },
      {
        name: "French Onion Soup",
        cuisine: "French",
        description: "Caramelized onions in beef broth, topped with gruyere and crusty bread",
        difficulty: "Medium",
        time: "1 hour"
      },
      {
        name: "Greek Moussaka",
        cuisine: "Greek",
        description: "Layered eggplant, spiced meat, and b√©chamel sauce baked to perfection",
        difficulty: "Hard",
        time: "2 hours"
      },
      {
        name: "Korean Bibimbap",
        cuisine: "Korean",
        description: "Rice bowl with vegetables, egg, gochujang sauce, and optional meat",
        difficulty: "Easy",
        time: "35 min"
      }
    ];

    // Check if online
    const isOnline = navigator.onLine;

    // WebSocket connection for real-time updates
    let ws = null;
    let onlineUsers = 0;

    function connectWebSocket() {
      if (!isOnline) return;

      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}`;

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        console.log('‚úì WebSocket connected for real-time updates');
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          if (data.type === 'elo_update') {
            // Another user voted - refresh leaderboard
            console.log('üìä ELO update received:', data);
            loadLeaderboard();
          } else if (data.type === 'connection') {
            // Initial connection message
            console.log('üîå Connected to server');
          } else if (data.type === 'online_users') {
            // Update online user count
            onlineUsers = data.count;
            updateOnlineCounter();
          }
        } catch (e) {
          console.error('WebSocket message parse error:', e);
        }
      };

      ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
      };

      ws.onclose = () => {
        console.log('üîå WebSocket disconnected, reconnecting in 3s...');
        setTimeout(connectWebSocket, 3000);
      };
    }

    function updateOnlineCounter() {
      const statusEl = document.getElementById('rateLimitStatus');
      if (statusEl && onlineUsers > 0) {
        const currentText = statusEl.innerHTML;
        if (!currentText.includes('üë•')) {
          statusEl.innerHTML = `${currentText} <span style="margin-left: 10px;">üë• ${onlineUsers} online</span>`;
        } else {
          statusEl.innerHTML = currentText.replace(/üë• \d+ online/, `üë• ${onlineUsers} online`);
        }
      }
    }

    // Initialize
    async function init() {
      if (typeof EloCalculator !== 'undefined') {
        eloCalc = new EloCalculator();
      }

      if (isOnline) {
        connectWebSocket();
        await initRecipes();
        await loadMatchup();
        await loadLeaderboard();
        await updateRateLimitDisplay();
      } else {
        // Offline mode - use LocalStorage
        initOfflineMode();
      }
    }

    // Initialize recipes in database (one-time setup)
    async function initRecipes() {
      try {
        for (const recipe of SAMPLE_RECIPES) {
          await fetch(`${API_URL}/item`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              item_type: 'recipe',
              item_name: recipe.name,
              item_data: recipe,
              created_by: 'system'
            })
          }).catch(() => {}); // Ignore if already exists
        }
      } catch (error) {
        console.log('Recipes may already be initialized');
      }
    }

    // Load a random matchup
    async function loadMatchup() {
      try {
        const response = await fetch(`${API_URL}/random/recipe`);
        const data = await response.json();

        if (data.status === 'ok') {
          currentMatchup = data;
          renderMatchup(data);
        }
      } catch (error) {
        console.error('Error loading matchup:', error);
        document.getElementById('vsContainer').innerHTML = `
          <div class="loading">Server offline. Please start the server.</div>
        `;
      }
    }

    // Render the matchup
    function renderMatchup(data) {
      const [recipeA, recipeB] = data.items;
      const prediction = data.prediction;

      // Track when matchup is shown
      voteStartTime = Date.now();

      matchNumber++;
      document.getElementById('matchCount').textContent = `Match #${matchNumber}`;

      // Show prediction
      const predictionDiv = document.getElementById('prediction');
      predictionDiv.style.display = 'block';
      document.getElementById('probA').textContent = `${prediction.probabilityA}%`;
      document.getElementById('probB').textContent = `${prediction.probabilityB}%`;
      document.getElementById('probA').style.width = `${prediction.probabilityA}%`;
      document.getElementById('probB').style.width = `${prediction.probabilityB}%`;

      // Render cards
      const tierA = getTier(recipeA.elo_rating);
      const tierB = getTier(recipeB.elo_rating);

      document.getElementById('vsContainer').innerHTML = `
        <div class="recipe-card" onclick="chooseWinner('${recipeA.id}')" data-id="${recipeA.id}">
          <div class="elo-rating">
            <div class="elo-number">${recipeA.elo_rating}</div>
            <div class="elo-label">ELO</div>
          </div>
          <div class="recipe-name">${recipeA.item_name}</div>
          <div class="recipe-cuisine">${recipeA.item_data.cuisine}</div>
          <div class="recipe-description">${recipeA.item_data.description}</div>
          <div class="tier-badge" style="background: ${tierA.color};">${tierA.icon} ${tierA.tier}</div>
          <div class="recipe-stats">
            <div class="stat">
              <div class="stat-label">Record</div>
              <div class="stat-value">${recipeA.wins || 0}-${recipeA.losses || 0}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Matches</div>
              <div class="stat-value">${recipeA.matches_played}</div>
            </div>
          </div>
        </div>

        <div class="vs-separator">VS</div>

        <div class="recipe-card" onclick="chooseWinner('${recipeB.id}')" data-id="${recipeB.id}">
          <div class="elo-rating">
            <div class="elo-number">${recipeB.elo_rating}</div>
            <div class="elo-label">ELO</div>
          </div>
          <div class="recipe-name">${recipeB.item_name}</div>
          <div class="recipe-cuisine">${recipeB.item_data.cuisine}</div>
          <div class="recipe-description">${recipeB.item_data.description}</div>
          <div class="tier-badge" style="background: ${tierB.color};">${tierB.icon} ${tierB.tier}</div>
          <div class="recipe-stats">
            <div class="stat">
              <div class="stat-label">Record</div>
              <div class="stat-value">${recipeB.wins || 0}-${recipeB.losses || 0}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Matches</div>
              <div class="stat-value">${recipeB.matches_played}</div>
            </div>
          </div>
        </div>
      `;
    }

    // Handle winner selection
    async function chooseWinner(winnerId) {
      if (!currentMatchup) return;

      // Check if user can swipe (free tier limit)
      if (!canSwipe()) {
        return; // Paywall shown, don't proceed
      }

      const [recipeA, recipeB] = currentMatchup.items;
      const winnerCard = document.querySelector(`.recipe-card[data-id="${winnerId}"]`);
      winnerCard.classList.add('winner');

      // Increment swipe count
      incrementSwipeCount();

      // Calculate vote duration
      const voteDuration = voteStartTime ? Date.now() - voteStartTime : null;

      try {
        const response = await fetch(`${API_URL}/match`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            item_a_id: recipeA.id,
            item_b_id: recipeB.id,
            winner_id: parseInt(winnerId),
            session_id: sessionId,
            device_id: deviceId,
            vote_duration_ms: voteDuration
          })
        });

        const data = await response.json();

        if (data.status === 'error') {
          // Handle specific error types
          if (data.code === 'RATE_LIMIT_EXCEEDED') {
            alert(`‚è∞ ${data.error}\n\n${data.suggestion}\n\nYou can vote again in ${data.resetIn} seconds.`);
            winnerCard.classList.remove('winner');
            return;
          } else if (data.code === 'DUPLICATE_VOTE') {
            alert(`‚úã ${data.error}\n\nYou already voted on this matchup. Try another one!`);
            winnerCard.classList.remove('winner');
            await loadMatchup();
            return;
          } else if (data.code === 'VOTER_BLOCKED') {
            alert(`üö´ ${data.error}\n\nIf you believe this is an error, please contact support.`);
            winnerCard.classList.remove('winner');
            return;
          }
        }

        console.log('Match recorded:', data);

        // Update rate limit display
        updateRateLimitDisplay();

        // Show rating changes
        setTimeout(async () => {
          await loadLeaderboard();
          await loadMatchup();
        }, 500);

      } catch (error) {
        console.error('Error recording match:', error);
        alert('Failed to record vote. Please try again.');
        winnerCard.classList.remove('winner');
      }
    }

    // Update rate limit status display
    async function updateRateLimitDisplay() {
      try {
        const response = await fetch(`${API_URL}/rate-limit-status`);
        const data = await response.json();

        if (data.status === 'ok') {
          const tierNames = {
            anonymous: 'Anonymous',
            registered: 'Registered',
            verified: 'Verified',
            trusted: 'Trusted'
          };

          const tierIcons = {
            anonymous: 'üë§',
            registered: '‚úì',
            verified: '‚úì‚úì',
            trusted: '‚≠ê'
          };

          const tierName = tierNames[data.tier] || data.tier;
          const tierIcon = tierIcons[data.tier] || '';

          document.getElementById('rateLimitStatus').innerHTML =
            `${tierIcon} ${tierName} <span class="tier-badge-small">${data.remaining}/${data.limit} votes remaining</span>`;
        }
      } catch (error) {
        console.error('Error loading rate limit status:', error);
        document.getElementById('rateLimitStatus').textContent = '';
      }
    }

    // Load leaderboard
    async function loadLeaderboard() {
      try {
        const response = await fetch(`${API_URL}/leaderboard?type=recipe&limit=10`);
        const data = await response.json();

        if (data.status === 'ok' && data.leaderboard.length > 0) {
          renderLeaderboard(data.leaderboard);

          // Update total matches
          const totalMatches = data.leaderboard.reduce((sum, item) => sum + item.matches_played, 0) / 2;
          document.getElementById('totalMatches').textContent = `Total matches: ${Math.floor(totalMatches)}`;
        }
      } catch (error) {
        console.error('Error loading leaderboard:', error);
      }
    }

    // Render leaderboard
    function renderLeaderboard(items) {
      const list = document.getElementById('leaderboardList');

      list.innerHTML = items.map((item, index) => {
        const tier = getTier(item.elo_rating);
        let rankClass = '';
        if (index === 0) rankClass = 'gold';
        else if (index === 1) rankClass = 'silver';
        else if (index === 2) rankClass = 'bronze';

        return `
          <div class="leaderboard-item">
            <div class="rank ${rankClass}">#${index + 1}</div>
            <div class="item-info">
              <div class="item-name">${item.item_name}</div>
              <div class="item-record">${item.wins || 0}-${item.losses || 0} ‚Ä¢ ${tier.icon} ${tier.tier}</div>
            </div>
            <div class="item-rating">${item.elo_rating}</div>
          </div>
        `;
      }).join('');
    }

    // Get tier info
    function getTier(rating) {
      if (rating < 1000) return { tier: 'Novice', color: '#94a3b8', icon: 'üå±' };
      if (rating < 1200) return { tier: 'Beginner', color: '#64748b', icon: 'ü•â' };
      if (rating < 1400) return { tier: 'Intermediate', color: '#06b6d4', icon: 'ü•à' };
      if (rating < 1600) return { tier: 'Advanced', color: '#3b82f6', icon: 'ü•á' };
      if (rating < 1800) return { tier: 'Expert', color: '#8b5cf6', icon: 'üíé' };
      if (rating < 2000) return { tier: 'Master', color: '#ec4899', icon: 'üëë' };
      if (rating < 2200) return { tier: 'Grandmaster', color: '#f59e0b', icon: '‚≠ê' };
      return { tier: 'Legend', color: '#ef4444', icon: 'üî•' };
    }

    // Offline mode fallback
    function initOfflineMode() {
      document.getElementById('vsContainer').innerHTML = `
        <div class="loading">
          <p>You're offline!</p>
          <p style="margin-top: 10px;">Start the server to use ELO ranking</p>
        </div>
      `;
    }

    // Check premium status on init
    function checkPremiumStatus() {
      // Check localStorage for premium status
      isPremium = localStorage.getItem('recipePremium') === 'true';

      // Load swipe count for today
      const today = new Date().toDateString();
      const lastDate = localStorage.getItem('recipeLastSwipeDate');

      if (lastDate !== today) {
        // New day - reset count
        swipesUsedToday = 0;
        localStorage.setItem('recipeLastSwipeDate', today);
        localStorage.setItem('recipeSwipeCount', '0');
      } else {
        swipesUsedToday = parseInt(localStorage.getItem('recipeSwipeCount') || '0');
      }

      updateSwipeCounter();
    }

    // Update swipe counter display
    function updateSwipeCounter() {
      const statusEl = document.getElementById('rateLimitStatus');

      if (isPremium) {
        statusEl.innerHTML = '‚≠ê Premium - Unlimited swipes';
      } else {
        const remaining = Math.max(0, FREE_SWIPES_PER_DAY - swipesUsedToday);
        statusEl.innerHTML = `${remaining}/${FREE_SWIPES_PER_DAY} free swipes remaining today`;

        if (remaining === 0) {
          statusEl.innerHTML += ' <span style="color: #ff4444;">- Upgrade for unlimited!</span>';
        }
      }
    }

    // Check if user can swipe
    function canSwipe() {
      if (isPremium) return true;
      if (swipesUsedToday >= FREE_SWIPES_PER_DAY) {
        showPaymentModal();
        Analytics.track('paywall_shown', {
          trigger: 'swipe_limit',
          swipes_used: swipesUsedToday
        });
        return false;
      }
      return true;
    }

    // Increment swipe count
    function incrementSwipeCount() {
      if (isPremium) return;

      swipesUsedToday++;
      localStorage.setItem('recipeSwipeCount', swipesUsedToday.toString());
      updateSwipeCounter();

      // Track swipe event
      Analytics.track('recipe_swipe', {
        swipe_number: swipesUsedToday,
        is_premium: isPremium,
        remaining_swipes: Math.max(0, FREE_SWIPES_PER_DAY - swipesUsedToday)
      });
    }

    // Show payment modal
    function showPaymentModal() {
      document.getElementById('paymentModal').classList.add('show');
      Analytics.trackFunnelStep('recipe_premium', 1, 'paywall_shown');
    }

    // Close payment modal
    function closePaymentModal() {
      document.getElementById('paymentModal').classList.remove('show');
      Analytics.track('paywall_dismissed', {
        swipes_used: swipesUsedToday
      });
    }

    // Upgrade to premium
    async function upgradeToPremium() {
      // Track conversion intent
      Analytics.trackConversion('upgrade', {
        value: 4.99,
        currency: 'USD'
      });
      Analytics.trackFunnelStep('recipe_premium', 2, 'upgrade_clicked');

      // Redirect to Stripe checkout (we'll implement this next)
      window.location.href = '/checkout/recipe-premium';
    }

    // Initialize on load
    checkPremiumStatus();
    init();

    // Track page load
    Analytics.track('recipe_app_loaded', {
      is_premium: isPremium,
      swipes_remaining: Math.max(0, FREE_SWIPES_PER_DAY - swipesUsedToday)
    });

    console.log('üç≥ Recipe ELO Ranker loaded!');
  </script>
</body>
</html>
